/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

/*
 * dlgNewClustering.java
 *
 * Created on 22-Sep-2010, 15:53:04
 */
package vortex.gui;

import java.awt.Component;
import java.awt.Frame;
import java.awt.Rectangle;
import java.io.ByteArrayOutputStream;
import java.io.FilterOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.PrintStream;
import java.util.List;
import javax.swing.DefaultComboBoxModel;
import javax.swing.JList;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.SwingWorker;
import javax.swing.plaf.basic.BasicComboBoxRenderer;
import samusik.glasscmp.GlassDialog;
import samusik.glasscmp.GlassPanel;
import sandbox.clustering.AngularDistance;
import sandbox.clustering.ClusterSet;
import sandbox.clustering.Dataset;
import sandbox.clustering.ClusteringAlgorithm;
import sandbox.clustering.DistanceMeasure;
import sandbox.clustering.EuclideanDistance;
import util.logger;
import vortex.clustering.HierarchicalClusteringCore;
import sandbox.clustering.K_medoids;
import sandbox.clustering.NoiseSuppressingAngularDistance;
import sandbox.clustering.NoiseSuppressingEuclideanDistance;
import java.lang.reflect.InvocationTargetException;

import vortex.clustering.XShiftClustering;
import vortex.util.ClassWrapper;
import vortex.util.ConnectionManager;

/**
 *
 * @author Nikolay
 */
public class dlgNewClustering extends GlassDialog {

    private static final long serialVersionUID = 1L;
    private ClusterSet[] clusterSets;
    private Dataset[] ds;
    private ClusteringWorker worker;

    /**
     * Creates new form dlgNewClustering
     *
     * @param parent - a frame to which this window belongs
     * @param ds - a dataset to cluster
     */
    public DistanceMeasure getDistanceMeasure() {
        if (cmbDistanceMeasure.getSelectedIndex() == -1) {
            return null;
        }
        Class<DistanceMeasure> c = ((ClassWrapper) cmbDistanceMeasure.getSelectedItem()).item;
        DistanceMeasure dm = null;
        try {
            dm = c.getConstructor().newInstance();
            dm.init(ds[0]);
        } catch (NoSuchMethodException | SecurityException | InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
            logger.showException(e);
        }
        return dm;
    }

    public dlgNewClustering(Frame parent, Dataset[] ds) {
        super(parent, true);
        this.ds = ds;
        jProgressBar1.setVisible(false);
        //scp1.setVisible(false);
        this.setTitle("New clustering: " + ds[0].getName());
        jTextArea1.append("Available CPUs: " + Runtime.getRuntime().availableProcessors()+ "\n");
        jTextArea1.append("Total Memory: " + Runtime.getRuntime().totalMemory() + "\n");
        jTextArea1.append("Free Memory: " + Runtime.getRuntime().freeMemory() + "\n");
        jTextArea1.append("Ready for clustering\n\n");
        jTextArea1.append("WARNING: clustering process might use all of your available CPUs. In order to prevent system unresponsiveness, it is recommended to change the priority of this application (displayed as java.exe in your task manager process list) to the lowest one, before starting the clustering.");

        this.setBounds(frmMain.getInstance().getWidth() / 2 - 400, frmMain.getInstance().getHeight() / 2 - 300, 800, 600);
        clusterSets = null;
        cmbAlgorithm.setRenderer(new ClusteringCoreComboBoxRenderer());

        Class<DistanceMeasure>[] c = new Class[]{AngularDistance.class, EuclideanDistance.class, NoiseSuppressingEuclideanDistance.class,  NoiseSuppressingAngularDistance.class};
        for (Class<DistanceMeasure> c1 : c) {
            ((DefaultComboBoxModel) cmbDistanceMeasure.getModel()).addElement(new vortex.util.ClassWrapper(c1));
        }
    }

    @Override
    protected void dialogInit() {
        super.dialogInit();
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {
        java.awt.GridBagConstraints gridBagConstraints;

        panIndependentClustering = new javax.swing.JPanel();
        jLabel18 = new javax.swing.JLabel();
        txtComment = new samusik.glasscmp.GlassEdit();
        cmbAlgorithm = new samusik.glasscmp.GlassComboBox();
        jLabel21 = new javax.swing.JLabel();
        panAlgorithmParams = new javax.swing.JPanel();
        panOutput = new javax.swing.JPanel();
        scp1 = new javax.swing.JScrollPane();
        jTextArea1 = new javax.swing.JTextArea();
        cmbDistanceMeasure = new samusik.glasscmp.GlassComboBox();
        jLabel22 = new javax.swing.JLabel();
        jProgressBar1 = new javax.swing.JProgressBar();
        cmdDoClustering = new samusik.glasscmp.GlassButton();

        setMinimumSize(new java.awt.Dimension(500, 400));
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent evt) {
                formWindowClosing(evt);
            }
        });
        getContentPane().setLayout(new java.awt.GridBagLayout());

        panIndependentClustering.setBackground(GlassPanel.BG_COLOR);
        panIndependentClustering.setMaximumSize(new java.awt.Dimension(2147483647, 100));
        panIndependentClustering.setMinimumSize(new java.awt.Dimension(738, 100));
        panIndependentClustering.setPreferredSize(new java.awt.Dimension(738, 100));
        panIndependentClustering.setLayout(new java.awt.GridBagLayout());

        jLabel18.setForeground(new java.awt.Color(0, 51, 102));
        jLabel18.setText("Add Comment:");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        gridBagConstraints.insets = new java.awt.Insets(4, 0, 5, 0);
        panIndependentClustering.add(jLabel18, gridBagConstraints);

        txtComment.setMinimumSize(new java.awt.Dimension(100, 28));
        txtComment.setPreferredSize(new java.awt.Dimension(200, 27));
        txtComment.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                txtCommentActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.insets = new java.awt.Insets(5, 10, 5, 0);
        panIndependentClustering.add(txtComment, gridBagConstraints);

        cmbAlgorithm.setModel(new javax.swing.DefaultComboBoxModel(new String[0]));
        cmbAlgorithm.setMinimumSize(new java.awt.Dimension(302, 30));
        cmbAlgorithm.setPreferredSize(new java.awt.Dimension(200, 27));
        cmbAlgorithm.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cmbAlgorithmActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        gridBagConstraints.insets = new java.awt.Insets(5, 10, 0, 0);
        panIndependentClustering.add(cmbAlgorithm, gridBagConstraints);

        jLabel21.setForeground(new java.awt.Color(0, 51, 102));
        jLabel21.setText("Distance Measure:");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        gridBagConstraints.insets = new java.awt.Insets(6, 0, 4, 1);
        panIndependentClustering.add(jLabel21, gridBagConstraints);

        panAlgorithmParams.setBorder(new samusik.glasscmp.GlassBorder());
        panAlgorithmParams.setMinimumSize(new java.awt.Dimension(200, 90));
        panAlgorithmParams.setOpaque(false);
        panAlgorithmParams.setPreferredSize(new java.awt.Dimension(200, 90));
        panAlgorithmParams.setLayout(new java.awt.BorderLayout());
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 3;
        gridBagConstraints.gridwidth = 2;
        gridBagConstraints.gridheight = 2;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.weighty = 0.3;
        gridBagConstraints.insets = new java.awt.Insets(5, 0, 0, 0);
        panIndependentClustering.add(panAlgorithmParams, gridBagConstraints);

        panOutput.setLayout(new java.awt.BorderLayout());

        jTextArea1.setEditable(false);
        jTextArea1.setColumns(20);
        jTextArea1.setLineWrap(true);
        jTextArea1.setRows(5);
        scp1.setViewportView(jTextArea1);

        panOutput.add(scp1, java.awt.BorderLayout.CENTER);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 6;
        gridBagConstraints.gridwidth = 2;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.weighty = 1.0;
        panIndependentClustering.add(panOutput, gridBagConstraints);

        cmbDistanceMeasure.setModel(new javax.swing.DefaultComboBoxModel(new String[0]));
        cmbDistanceMeasure.setMinimumSize(new java.awt.Dimension(302, 30));
        cmbDistanceMeasure.setPreferredSize(new java.awt.Dimension(200, 27));
        cmbDistanceMeasure.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cmbDistanceMeasureActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        gridBagConstraints.insets = new java.awt.Insets(5, 10, 0, 0);
        panIndependentClustering.add(cmbDistanceMeasure, gridBagConstraints);

        jLabel22.setForeground(new java.awt.Color(0, 51, 102));
        jLabel22.setText("Clustering Algorithm:");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        gridBagConstraints.insets = new java.awt.Insets(6, 0, 4, 1);
        panIndependentClustering.add(jLabel22, gridBagConstraints);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.gridwidth = 2;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.weighty = 1.0;
        gridBagConstraints.insets = new java.awt.Insets(5, 5, 0, 5);
        getContentPane().add(panIndependentClustering, gridBagConstraints);

        jProgressBar1.setMaximumSize(new java.awt.Dimension(250, 19));
        jProgressBar1.setMinimumSize(new java.awt.Dimension(250, 19));
        jProgressBar1.setPreferredSize(new java.awt.Dimension(250, 19));
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.insets = new java.awt.Insets(5, 5, 0, 0);
        getContentPane().add(jProgressBar1, gridBagConstraints);

        cmdDoClustering.setText("Go!");
        cmdDoClustering.setMaximumSize(new java.awt.Dimension(80, 35));
        cmdDoClustering.setMinimumSize(new java.awt.Dimension(80, 35));
        cmdDoClustering.setPreferredSize(new java.awt.Dimension(80, 35));
        cmdDoClustering.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cmdDoClusteringActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        gridBagConstraints.insets = new java.awt.Insets(5, 0, 5, 5);
        getContentPane().add(cmdDoClustering, gridBagConstraints);

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void txtCommentActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_txtCommentActionPerformed
        // TODO add your handling code here:
}//GEN-LAST:event_txtCommentActionPerformed

    private void cmbAlgorithmActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cmbAlgorithmActionPerformed
        panAlgorithmParams.removeAll();
        JPanel pan = ((ClusteringAlgorithm) cmbAlgorithm.getSelectedItem()).getParamControlPanel();
        panAlgorithmParams.add(pan);
        panAlgorithmParams.setMinimumSize(pan.getMinimumSize());
        panAlgorithmParams.setPreferredSize(pan.getPreferredSize());
        panAlgorithmParams.setBounds(panAlgorithmParams.getBounds().x, panAlgorithmParams.getBounds().y, pan.getPreferredSize().width, pan.getPreferredSize().height);
        pan.setBounds(panAlgorithmParams.getBounds().x, panAlgorithmParams.getBounds().y, pan.getPreferredSize().width, pan.getPreferredSize().height);
        this.invalidate();
        panAlgorithmParams.invalidate();
        pan.invalidate();
        panAlgorithmParams.repaint();
        pan.invalidate();
        pan.doLayout();
        panAlgorithmParams.doLayout();
        this.doLayout();
        synchronized (getTreeLock()) {
            this.validateTree();
        }
        panAlgorithmParams.validate();
        this.repaint();
}//GEN-LAST:event_cmbAlgorithmActionPerformed

    private class ClusteringCoreComboBoxRenderer extends BasicComboBoxRenderer {

        private static final long serialVersionUID = 1L;

        @Override
        public Component getListCellRendererComponent(JList list, Object value,
                int index, boolean isSelected, boolean cellHasFocus) {
            ClusteringAlgorithm cc = null;
            if (ClusteringAlgorithm.class.isAssignableFrom(value.getClass())) {
                cc = (ClusteringAlgorithm) value;
            }
            if (isSelected) {
                setBackground(list.getSelectionBackground());
                setForeground(list.getSelectionForeground());
            } else {
                setBackground(cmbAlgorithm.getBackground());
                setForeground(cmbAlgorithm.getForeground());
            }
            if (cc != null) {
                list.setToolTipText(cc.getAlgorithmDescription());
            }
            setFont(list.getFont());
            setText((cc != null) ? cc.getAlgorithmName() : value.toString());
            return this;
        }
    }

    public ClusterSet[] getClusterSets() {
        return clusterSets;
    }

    private class ClusteringWorker extends SwingWorker<ClusterSet[][], ClusterSet> {

        ClusteringAlgorithm core;

        public ClusteringWorker(ClusteringAlgorithm core) {
            this.core = core;
        }

        @Override
        protected ClusterSet[][] doInBackground() throws Exception {
            final ClusterSet[][] clusterSets = new ClusterSet[ds.length][];
            for (int i = 0; i < ds.length; i++) {
                if (isCancelled()) {
                    break;
                }

                try {
                    final int idx = i;
                    Thread t = new Thread() {
                        @Override
                        public void run() {
                            clusterSets[idx] = core.doBatchClustering(ds[idx], txtComment.getText());
                        }
                    };
                    t.start();
                    do {
                        try {
                            Thread.currentThread().sleep(10);
                        } catch (InterruptedException e) {
                            t.interrupt();
                        }
                        if (isCancelled()) {
                            t.interrupt();
                        }
                    } while (t.isAlive());
                    //Scorer scorer = new Scorer(ds);

                    for (ClusterSet clusterSet : clusterSets[i]) {
                        if (clusterSet == null) {
                            continue;
                        }
                        logger.print("Saving ClusterSet " + clusterSet.toString());
                        ConnectionManager.getStorageEngine().saveClusterSet(clusterSet, true);
                    }
                    publish(clusterSets[i]);

                } catch (Exception e) {
                    logger.showException(e);
                }
            }
            dlgNewClustering.this.setVisible(false);
            return clusterSets;
        }

        @Override
        protected void process(List<ClusterSet> chunks) {
            for (ClusterSet cs : chunks) {
            }
        }
    }

    class FilteredStream extends FilterOutputStream {

        public FilteredStream(OutputStream aStream) {
            super(aStream);
        }

        @Override
        public void write(byte b[]) throws IOException {
            String aString = new String(b);
            jTextArea1.append(aString);
            scp1.getVerticalScrollBar().setValue(scp1.getVerticalScrollBar().getMaximum());
            jTextArea1.scrollRectToVisible(new Rectangle(0, jTextArea1.getHeight()-scp1.getHeight(), jTextArea1.getWidth(), scp1.getHeight()));
        }

        @Override
        public void write(byte b[], int off, int len) throws IOException {
            String aString = new String(b, off, len);
            jTextArea1.append(aString);
             scp1.getVerticalScrollBar().setValue(scp1.getVerticalScrollBar().getMaximum());
            jTextArea1.scrollRectToVisible(new Rectangle(0, jTextArea1.getHeight()-scp1.getHeight(), jTextArea1.getWidth(), scp1.getHeight()));
        }
    }

    private boolean tryInterruptClustering() {
        if (worker != null) {
            if (JOptionPane.showConfirmDialog(this, "Are you sure you want to interrupt the current clustering run?") == JOptionPane.OK_OPTION) {
                worker.cancel(true);
                worker = null;
                return true;
            }
        }
        return false;
    }

    private void cmdDoClusteringActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cmdDoClusteringActionPerformed

        logger.setAdditionalWriter(new PrintStream(new FilteredStream(new ByteArrayOutputStream())));

        if (tryInterruptClustering()) {
            jProgressBar1.setIndeterminate(false);
            jProgressBar1.setVisible(false);
            jProgressBar1.setStringPainted(false);
            jProgressBar1.setString("");
            jProgressBar1.setValue(0);
            cmdDoClustering.setText("Go!");
            logger.print("Clustering run interrupted");
            return;
        }

        jProgressBar1.setVisible(true);
        jProgressBar1.setIndeterminate(true);
        jProgressBar1.setString("Clustering...");
        jProgressBar1.setStringPainted(true);

        worker = new ClusteringWorker(((ClusteringAlgorithm) cmbAlgorithm.getSelectedItem()));
        worker.execute();
        logger.print("Clustering started");
        cmdDoClustering.setText("Stop");

        /*
         try {
         int[] selRows = tabDatasets.getSelectedRows();
         for (int f2 : selRows) {
        
         String DatasetID = (String) tabDatasets.getValueAt(f2, 0);
         Dataset ds = Dataset.getInstance(DatasetID);
        
        
         DefaultMutableTreeNode root = (DefaultMutableTreeNode) jTree1.getModel().getRoot();
        
         for (ClusterSet cs : css) {
         HideableMutableTreeNode nodeCS = new HideableMutableTreeNode(cs);
         ((HideableTreeModel) jTree1.getModel()).insertNodeInto(nodeCS, root, root.getChildCount());
         for (Cluster f : ((ClusterSet) nodeCS.getUserObject()).getClusters()) {
         ((HideableTreeModel) jTree1.getModel()).insertNodeInto(new HideableMutableTreeNode(f), nodeCS, nodeCS.getChildCount());
         }
         }
         }
         ((DefaultTreeModel) jTree1.getModel()).reload();
         } catch (Exception e) {
         e.printStackTrace();
         }
         */
}//GEN-LAST:event_cmdDoClusteringActionPerformed

    private void formWindowClosing(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_formWindowClosing
        if (tryInterruptClustering()) {
            this.setVisible(false);
            this.dispose();
        }
    }//GEN-LAST:event_formWindowClosing

    private void cmbDistanceMeasureActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cmbDistanceMeasureActionPerformed
        cmbAlgorithm.setModel(new DefaultComboBoxModel());

        for (ClusteringAlgorithm cc : new ClusteringAlgorithm[]{new XShiftClustering(getDistanceMeasure(),ds[0]),
            new HierarchicalClusteringCore(getDistanceMeasure()),
            new K_medoids(getDistanceMeasure()),
        }) {
            ((DefaultComboBoxModel) cmbAlgorithm.getModel()).addElement(cc);
        }

    }//GEN-LAST:event_cmbDistanceMeasureActionPerformed
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private samusik.glasscmp.GlassComboBox cmbAlgorithm;
    private samusik.glasscmp.GlassComboBox cmbDistanceMeasure;
    private samusik.glasscmp.GlassButton cmdDoClustering;
    private javax.swing.JLabel jLabel18;
    private javax.swing.JLabel jLabel21;
    private javax.swing.JLabel jLabel22;
    private javax.swing.JProgressBar jProgressBar1;
    private javax.swing.JTextArea jTextArea1;
    private javax.swing.JPanel panAlgorithmParams;
    private javax.swing.JPanel panIndependentClustering;
    private javax.swing.JPanel panOutput;
    private javax.swing.JScrollPane scp1;
    private samusik.glasscmp.GlassEdit txtComment;
    // End of variables declaration//GEN-END:variables
}
